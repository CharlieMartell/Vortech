{
  "name": "redux-requests",
  "version": "1.0.2",
  "description": "Manages in-flight requests with a Redux reducer - avoid issuing duplicate requests without any special logic!",
  "main": "lib/index.js",
  "jsnext:main": "index.js",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/idolize/redux-requests.git"
  },
  "keywords": [
    "redux",
    "react",
    "flux",
    "http",
    "request",
    "requests",
    "pending",
    "flight"
  ],
  "author": {
    "name": "David Idol"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/idolize/redux-requests/issues"
  },
  "homepage": "https://github.com/idolize/redux-requests#readme",
  "scripts": {
    "prepublish": "babel index.js --out-dir lib",
    "test": "mocha --compilers js:babel/register test"
  },
  "dependencies": {},
  "devDependencies": {
    "babel": "^5.8.21",
    "chai": "^3.2.0",
    "chai-as-promised": "^5.1.0",
    "es6-promise": "^3.0.2",
    "mocha": "^2.2.5"
  },
  "readme": "redux-requests [![Version][npm-image]][npm-url]\n===================\n\nManages in-flight requests with a [Redux](https://github.com/gaearon/redux) [reducer](https://gaearon.github.io/redux/docs/basics/Reducers.html) - avoid issuing duplicate requests without any special logic!\n\n`npm install --save redux-requests`\n\n**[Live Example!](https://idolize.github.io/redux-requests)**\n\n## Avoiding the issue of multiple requests\n\nSay your application has two views for the same set of data, and this data has not yet been fetched. A naïve approach to fetch this data would be to trigger an [Action Creator](https://gaearon.github.io/redux/docs/basics/Actions.html), which fetches the data from an HTTP API endpoint, in both of the views as soon as they render (`componentWillMount` in React terms).\n\nThe problem with this approach is that **you end up with two identical HTTP requests when you only need one**! You waste bandwidth doing this, and you may also waste render cycles as the [Store](https://gaearon.github.io/redux/docs/basics/Store.html) updates twice as a result of handling both identical responses.\n\n### How can we fix this?\n\nYou could wrap all your calls to fetch the data with `if` statements, and keep track of that state somewhere, but who wants to do that by hand?\n\n### Enter: redux-requests\n\nThis library will not only keep track of all pending requests for you, but also provide a convenient [middleware](https://gaearon.github.io/redux/docs/api/applyMiddleware.html) function that will avoid dispatching Actions to request data if there is already a pending HTTP request for this data in flight!\n\nAs a result, you can use the *very same naïve approach outlined earlier with hardly any code changes* and it will \"just work\"! Keep your views stateless and your Reducers ignorant of the notion of \"pending requests\"!\n\n## Simple example\n\nJust specify a function that makes the request (should return a `Promise`), Action objects to dispatch depending on the outcome of the request, and register the `createRequestMiddleware` middleware and the `requestsReducer` reducer as part of your Redux configuration. That's it.\n\n```js\nimport { attemptRequest, requestsReducer, createRequestMiddleware } from 'redux-requests';\n// Attempt to make a request if there isn't one for this URL already\nfunction loadRepos(userId) {\n  // Using redux-thunk middleware here, but other options should work as well\n  return function (dispatch, getState) {\n    const url = `https://api.github.com/users/${userId}/repos`;\n\n    attemptRequest(url, {\n      begin: () => ({\n        type: 'LOAD_REPOS',\n        payload: {\n          userId\n        }\n      }),\n      success: response => ({\n        type: 'LOAD_REPOS',\n        payload: {\n          userId,\n          response\n        }\n      }),\n      failure: error => ({\n        type: 'LOAD_REPOS',\n        error,\n        payload: {\n          userId\n        }\n      })\n    }, () => fetch(url)\n      .then(checkStatus)\n      .then(parseJSON)\n    , dispatch);\n  }\n}\n// Add additional reducer and middleware\nconst createStoreWithMiddleware = applyMiddleware(thunkMiddleware, createRequestMiddleware())(createStore);\nlet store = createStoreWithMiddleware(combineReducers({ requestsReducer, githubRepos }));\n```\n\n## What's going on: before and after\n\nThe `attemptRequest` function is actually just a simple helper (and is completely optional). All it does is:\n\n1. Add `meta.httpRequest` fields to your Action objects\n  - `meta.httpRequest.url` is required, and will be used as the unique identifier for the request\n  - `meta.httpRequest.done` is a boolean indiecating if this action corresponds to a beginning or ending part of the request sequence\n    - Typically a successful response Action and a failed response Action will both have `meta.httpRequest.done = true`\n2. Check if the `dispatch` for your initial request Action was cancelled (`dispatch` will return `undefined`), and if so, prevent issuing the request\n\n#### Original, naïve code (without redux-requests library):\n\n```js\n// React component\nclass Repos extends Component {\n  constructor(props) {\n    super(props);\n  }\n\n  componentWillMount() {\n    // Action Creator attempts to request data for this user\n    this.props.loadRepos(this.props.username);\n  }\n\n  render() {\n    return (\n      <div>\n        { this.props.repos }\n      </div>\n    );\n  }\n}\n\nfunction mapStateToProps(state)  {\n  return {\n    repos: state.githubRepos\n  };\n}\n\nfunction mapDispatchToProps(dispatch) {\n  return {\n    loadRepos: (userId) => { dispatch(loadRepos(userId)); }\n  };\n}\n\nexport const ReposComponent = connect(mapStateToProps, mapDispatchToProps)(Repos);\n\n// Action Creator\nexport function loadRepos(userId) {\n  return function (dispatch, getState) {\n    const url = `https://api.github.com/users/${userId}/repos`;\n\n    dispatch({\n      type: 'LOAD_REPOS',\n      payload: {\n        userId\n      }\n    });\n\n    fetch(url)\n      .then(response => dispatch({\n        type: 'LOAD_REPOS',\n        payload: {\n          userId,\n          response\n        }\n      }))\n      .catch(error => dispatch({\n        type: 'LOAD_REPOS',\n        error: true,\n        payload: {\n          userId,\n          error\n        }\n      })\n    );\n  }\n}\n\n// Store\nconst createStoreWithMiddleware = applyMiddleware(thunkMiddleware)(createStore);\nlet store = createStoreWithMiddleware(combineReducers({ githubRepos }));\n```\n\n#### New code (using redux-requests to manage pending requests):\n\n```js\n// React component stays exactly the same!\n\n// Action Creator changes slightly\nexport function loadRepos(userId) {\n  return function (dispatch, getState) {\n    const url = `https://api.github.com/users/${userId}/repos`;\n\n    if (!dispatch({\n      type: 'LOAD_REPOS',\n      payload: {\n        userId\n      },\n      meta: {\n        // Add metadata to the action\n        httpRequest: { url, done: false }\n      }\n    })) {\n      return; // bail out here if the middleware cancelled the dispatch\n    }\n\n    fetch(url)\n      .then(response => dispatch({\n        type: 'LOAD_REPOS',\n        payload: {\n          userId,\n          response\n        },\n        meta: {\n          // Add metadata to the action\n          httpRequest: { url, done: true }\n        }\n      }))\n      .catch(error => dispatch({\n        type: 'LOAD_REPOS',\n        error: true,\n        payload: {\n          userId,\n          error\n        },\n        meta: {\n          // Add metadata to the action\n          httpRequest: { url, done: true }\n        }\n      })\n    );\n  }\n}\n\n// Add additional reducer and middleware\nimport { requestsReducer, createRequestMiddleware } from 'redux-requests';\nconst createStoreWithMiddleware = applyMiddleware(thunkMiddleware, createRequestMiddleware())(createStore);\nlet store = createStoreWithMiddleware(combineReducers({ requestsReducer, githubRepos }));\n```\n\n## API\n\n### `requestsReducer(state, action)`\n\nA reducer that keeps track of pending request state. It only operates on actions containing the `meta.httpRequest` field.\n\n### `createRequestMiddleware(stateSelectorFunction)`\n\nReturns a middleware function to pass to `applyMiddleware`. Optionally pass a `stateSelectorFunction` which returns where the `requestsReducer` keeps its state in the Store (if not passed, will default to `state => state.requests`).\n\nEx: `applyMiddleware(createRequestMiddleware(state => state.pendingHttpRequests))(createStore)`\n\n### `attemptRequest(url, actions, makeRequest, dispatch)`\n\nHelper function to reduce boilerplate when issuing a request, while still allowing full control over the way in which the request is made/handled.\n\n- `url` is the unique URL for this request.\n- `actions` should be an object with `begin`, `success`, and `failure` methods; each of which return an Action object (but do not need to include the `meta.httpRequest` information, as that will be added automatically).\n- `makeRequest` should return a `Promise` (how you make/handle the request is up to you).\n- `dispatch` is function called when an Action is triggered (typically this will be the standard Redux store's `dispatch` method).\n\n\n## Credits\n\n- Author: [David Idol](http://daveidol.com)\n- License: [MIT](http://opensource.org/licenses/MIT)\n\nInspired by the [Marty fetch API](http://martyjs.org/guides/fetching-state/index.html).\n\n[npm-image]: https://img.shields.io/npm/v/redux-requests.svg?style=flat-square\n[npm-url]: https://www.npmjs.org/package/redux-requests\n",
  "readmeFilename": "README.md",
  "_id": "redux-requests@1.0.2",
  "_from": "redux-requests@~1.0.2"
}
